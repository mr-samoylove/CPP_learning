
 # Реализация аналога популярной концепции MapReduce в терминах потоков в C++

Задача взята [отсюда](https://stepik.org/lesson/58810/step/4?unit=36391), вот ее описание:
>В данной задаче от вас потребуется реализовать аналоги популярной концепции MapReduce в терминах потоков.  
>Напишите функцию map_reduce, которая принимает на вход:
> * итератор на начало последовательности,
> * итератор на конец последовательности,
> * унарный функтор, который можно применить к элементам последовательности,
> * бинарный функтор, который можно применить к результатам применения первого функтора,
> * количество потоков.

>Результат вызова map_reduce  
>`auto res = map_reduce(p, q, f1, f2, num);`  
>должен быть эквивалентен результату следующего кода:
>
>`auto res = f1(*p);`  
>`while(++p != q)`  
>`    res = f2(res, f1(*p));`  
>только выполнение этого кода должно быть разбито на num потоков.

## Пример:

>std::list<int> l = {1,2,3,4,5,6,7,8,9,10};  
>// параллельное суммирование в 3 потока  
>`auto sum = map_reduce(l.begin(), l.end(),`   
>             `[](int i){return i;},`   
>             `std::plus<int>(), 3);`    
>
>// проверка наличия чётных чисел в четыре потока  
>`auto has_even = map_reduce(l.begin(), l.end(),`   
>                 `[](int i){return i % 2 == 0;},` 
>                `std::logical_or<bool>(), 4);`  

## Гарантии:

Длина последовательности не меньше количества потоков.
Функция f2 ассоциативна.  
## Требования:

Реализовать map_reduce нужно с использование std::async.  
Функция не должна изменять или копировать последовательность.  
У потоков не должно быть разделяемых неконстантных данных (соответственно, не нужны примитивы синхронизации).

